#
# This makefile has the rules necessary for making the custom version of coreneuron
# executable called "special_exe-core" from various mod files.
# Mod files are looked up in the cwd, unless MODS_PATH is set

# build system OS
OS_NAME := $(shell uname)

# ","" is argument separator, never as a literal
COMMA_OP =,

# Default variables for various targets
MECHLIB_SUFFIX =
MODS_PATH = .
OUTPUT_DIR = @CMAKE_HOST_SYSTEM_PROCESSOR@
NMODL_BINARY =

# CoreNEURON installation directories
INSTALL_BIN_DIR := $(ROOT)/bin
INSTALL_LIB_DIR := $(ROOT)/lib
INSTALL_INC_DIR := $(ROOT)/include
INSTALL_SHARE_CORENRN_DIR:= $(ROOT)/share/coreneuron
INSTALL_SHARE_MOD2C_DIR := $(ROOT)/share/mod2c

# Paths for building/compiling
MOD_TO_CPP_DIR = $(OUTPUT_DIR)/core/mod2c
MOD_OBJS_DIR = $(OUTPUT_DIR)/core/build

# Linked libraries used by CMake
LDFLAGS = $(LINKFLAGS) @CORENRN_LINK_DEFS@
CORENRNLIB_FLAGS = -L$(INSTALL_LIB_DIR) -lcoreneuron
CORENRNLIB_FLAGS += $(if @reportinglib_LIB_DIR@, -W$(subst ;, -W,l,-rpath,@reportinglib_LIB_DIR@),)
CORENRNLIB_FLAGS += $(if @sonatareport_LIB_DIR@, -W$(subst ;, -W,l,-rpath,@sonatareport_LIB_DIR@),)

# Includes paths used by CMake
INCLUDES = $(INCFLAGS) -I$(INSTALL_INC_DIR) -I$(INSTALL_INC_DIR)/coreneuron/utils/randoms
INCLUDES += $(if @MPI_C_INCLUDE_PATH@, -I$(subst ;, -I,@MPI_C_INCLUDE_PATH@),)
INCLUDES += $(if @reportinglib_INCLUDE_DIR@, -I$(subst ;, -I,@reportinglib_INCLUDE_DIR@),)

# Various C++ compiler related commands
CXX = @CMAKE_CXX_COMPILER@
CXXFLAGS = @BUILD_TYPE_CXX_FLAGS@ @CMAKE_CXX_FLAGS@ @CXX14_STANDARD_COMPILE_OPTION@ @PGI_INLINE_FLAGS@
CXX_COMPILE_CMD = $(CXX) $(CXXFLAGS) @CMAKE_CXX_COMPILE_OPTIONS_PIC@ @CORENRN_COMPILE_DEFS@ $(INCLUDES)
CXX_LINK_EXE_CMD = $(CXX) $(CXXFLAGS) @CMAKE_EXE_LINKER_FLAGS@
CXX_SHARED_LIB_CMD = $(CXX) $(CXXFLAGS) @CMAKE_SHARED_LIBRARY_CREATE_CXX_FLAGS@ @CMAKE_SHARED_LIBRARY_CXX_FLAGS@ @CMAKE_SHARED_LINKER_FLAGS@

# Compiler, flags and include paths for ISPC
ISPC = @CMAKE_ISPC_COMPILER@
ISPC_FLAGS = @CMAKE_ISPC_FLAGS@
ISPC_COMPILE_CMD = $(ISPC) $(ISPC_FLAGS) -I$(INSTALL_INC_DIR)

# file provided by coreneuron
DERIVIMPLICIT_CPP_FILE = $(INSTALL_SHARE_CORENRN_DIR)/dimplic.cpp

# env variables required for mod2c or nmodl
NMODL_ENV_VAR = PYTHONPATH=@CORENRN_NMODL_PYTHONPATH@:${INSTALL_LIB_DIR}/python MODLUNIT=$(INSTALL_SHARE_MOD2C_DIR)/nrnunits.lib

# various header and C++/Object file
KINDERIV_H_PATH = $(MOD_TO_CPP_DIR)/_kinderiv.h
MOD_FUNC_CPP = $(MOD_TO_CPP_DIR)/_mod_func.cpp
MOD_FUNC_OBJ = $(MOD_OBJS_DIR)/_mod_func.o
DIMPLIC_CPP  = $(MOD_TO_CPP_DIR)/_dimplic.cpp
DIMPLIC_OBJ  = $(MOD_OBJS_DIR)/_dimplic.o

ifeq (@COMPILE_LIBRARY_TYPE@, STATIC)
    LIB_SUFFIX = @CMAKE_STATIC_LIBRARY_SUFFIX@
    corenrnmech_lib_target = coremech_lib_static
else
    LIB_SUFFIX = @CMAKE_SHARED_LIBRARY_SUFFIX@
    corenrnmech_lib_target = coremech_lib_shared
endif

# Binary of MOD2C/NMODL depending on which was activated
ifeq (@nmodl_FOUND@, TRUE)
    NMODL_BINARY_PATH = $(if $(NMODL_BINARY),$(NMODL_BINARY), @CORENRN_NMODL_BINARY@)
    INCLUDES += -I@CORENRN_NMODL_INCLUDE@
    ISPC_COMPILE_CMD += -I@CORENRN_NMODL_INCLUDE@
else
    NMODL_BINARY_PATH = $(if $(NMODL_BINARY),$(NMODL_BINARY), $(INSTALL_BIN_DIR)/@nmodl_binary_name@)
endif

# mod files with full path, without path and without mod extension
mod_files_paths = $(sort $(wildcard $(MODS_PATH)/*.mod))
mod_files = $(sort $(notdir $(wildcard $(MODS_PATH)/*.mod)))
mod_files_no_ext = $(mod_files:.mod=)

# Variables used in the "ARTIFICIAL_CELL" detection
mod_c_srcs_path =
mod_ispc_srcs_path =
mod_ispc_srcs_names =

define check_file
	ifeq (@CORENRN_ENABLE_ISPC@, ON)
		ifeq ($(shell grep -q $(2) $(1); echo $$?), 0)
			mod_c_srcs_path += $(MOD_TO_CPP_DIR)/$(notdir $(1))
		else
			mod_ispc_srcs_path += $(MOD_TO_CPP_DIR)/$(notdir $(1))
		endif
	else
		mod_c_srcs_path += $(MOD_TO_CPP_DIR)/$(notdir $(1))
	endif
endef

$(foreach mod_file, $(mod_files_paths), $(eval $(call check_file, $(mod_file), ARTIFICIAL_CELL)))

mod_all_cpp_files = $(addprefix $(MOD_TO_CPP_DIR)/,$(addsuffix .cpp,$(mod_files_no_ext)))
mod_c_objs = $(addprefix $(MOD_OBJS_DIR)/,$(addsuffix .o,$(basename $(mod_files_no_ext)))) $(addprefix $(MOD_OBJS_DIR)/,$(addsuffix .o,$(basename $(filter %.cpp, $(OPTMODS_OUTPUT_DIRS)))))
mod_ispc_objs = $(addprefix $(MOD_OBJS_DIR)/,$(addsuffix .obj,$(basename $(mod_ispc_srcs_names)))) $(addprefix $(MOD_OBJS_DIR)/,$(addsuffix .obj,$(basename $(filter %.ispc, $(OPTMODS_OUTPUT_DIRS)))))

mod_c_files = $(patsubst %.mod,%.cpp,$(mod_c_srcs_path))
mod_ispc_srcs_names = $(notdir $(mod_ispc_srcs_path))
mod_ispc_files = $(patsubst %.mod,%.ispc,$(mod_ispc_srcs_path))
mod_ispc_c_files = $(patsubst %.mod,%.cpp,$(mod_ispc_srcs_path))

# name of binary
special_exe  = $(OUTPUT_DIR)/special-core

# name of library, with suffix if provided
coremech_libname = corenrnmech$(if $(MECHLIB_SUFFIX),_$(MECHLIB_SUFFIX),)
coremech_lib = $(OUTPUT_DIR)/lib$(coremech_libname)$(LIB_SUFFIX)

# we use $ORIGIN (@loader_path in OSX)
LIB_RPATH := $(if $(filter Darwin,$(OS_NAME)),@loader_path,$$ORIGIN)
SONAME_OPTION := -Wl,$(if $(filter Darwin,$(OS_NAME)),-install_name${COMMA_OP}@rpath/,-soname${COMMA_OP})$(notdir ${coremech_lib})

C_RESET := \033[0m
C_GREEN := \033[32m

all_object_files = $(MOD_FUNC_OBJ) $(DIMPLIC_OBJ) $(mod_c_objs) $(mod_ispc_objs)

current_dir = $(shell pwd)


# ======== MAIN BUILD RULES ============


# main target to build binary
$(special_exe): coremech_lib
	@printf " => $(C_GREEN)Binary$(C_RESET) creating $(special_exe)\n"
	$(CXX_LINK_EXE_CMD) -o $(special_exe) $(INSTALL_SHARE_CORENRN_DIR)/coreneuron.cpp \
	  -I$(INSTALL_INC_DIR) $(INCFLAGS) \
	  -L$(OUTPUT_DIR) $(LDFLAGS) $(CORENRNLIB_FLAGS) -l$(coremech_libname) \
	  -Wl,-rpath,$(LIB_RPATH) -Wl,-rpath,$(INSTALL_LIB_DIR)

coremech_lib: enginemech_object $(corenrnmech_lib_target)
	rm -rf $(OUTPUT_DIR)/.libs; \
	mkdir -p $(OUTPUT_DIR)/.libs; \
	ln -s $(OUTPUT_DIR)/${coremech_lib} $(OUTPUT_DIR)/.libs/libcorenrnmech$(LIB_SUFFIX)

enginemech_object:
	$(CXX_COMPILE_CMD) -c -DADDITIONAL_MECHS $(INSTALL_SHARE_CORENRN_DIR)/enginemech.cpp

coremech_lib_shared: $(all_object_files) build_always
	$(CXX_SHARED_LIB_CMD) enginemech.o -o ${coremech_lib} $(all_object_files) \
	  -I$(INSTALL_INC_DIR) $(INCFLAGS) \
	  $(LDFLAGS) $(INSTALL_LIB_DIR)/libscopmath.a \
	  ${SONAME_OPTION} $(CORENRNLIB_FLAGS) -Wl,-rpath,$(INSTALL_LIB_DIR);

coremech_lib_static: $(all_object_files) build_always
	mkdir -p $(MOD_OBJS_DIR)/scopmath; \
	cd $(MOD_OBJS_DIR)/scopmath && ar -x $(INSTALL_LIB_DIR)/libscopmath.a && cd -;\
	ar cq ${coremech_lib} enginemech.o $(all_object_files) $(MOD_OBJS_DIR)/scopmath/*.o;

# generic build cpp->.o Need PIC for shared lib
$(MOD_OBJS_DIR)/%.o: $(MOD_TO_CPP_DIR)/%.cpp $(KINDERIV_H_PATH) | $(MOD_OBJS_DIR)
	$(CXX_COMPILE_CMD) -c $< -o $@

# generic build ispc->.obj Need PIC for shared lib
$(MOD_OBJS_DIR)/%.obj: $(MOD_TO_CPP_DIR)/%.ispc | $(MOD_OBJS_DIR)
	$(ISPC_COMPILE_CMD) $< -o $@

# build ispc files with mod2c/nmodl
$(mod_ispc_files): $(MOD_TO_CPP_DIR)/%.ispc: $(MODS_PATH)/%.mod | $(MOD_TO_CPP_DIR)
	$(NMODL_ENV_VAR) $(NMODL_BINARY_PATH) $< -o $(MOD_TO_CPP_DIR)/ @nmodl_arguments_ispc@

# static pattern to set up the dependencies for the previous recipe.
$(mod_ispc_c_files): $(MOD_TO_CPP_DIR)/%.cpp: $(MOD_TO_CPP_DIR)/%.ispc

# build cpp files with mod2c/nmodl
$(mod_c_files): $(MOD_TO_CPP_DIR)/%.cpp: $(MODS_PATH)/%.mod | $(MOD_TO_CPP_DIR)
	$(NMODL_ENV_VAR) $(NMODL_BINARY_PATH) $< -o $(MOD_TO_CPP_DIR)/ @nmodl_arguments_c@

# generate mod registration function. Dont overwrite if not changed
$(MOD_FUNC_CPP): build_always | $(MOD_TO_CPP_DIR)
	@PERL_EXECUTABLE@ $(INSTALL_SHARE_CORENRN_DIR)/mod_func.c.pl $(mod_files) > $(MOD_FUNC_CPP).tmp
	diff -q $(MOD_FUNC_CPP).tmp $(MOD_FUNC_CPP) || \
	mv $(MOD_FUNC_CPP).tmp $(MOD_FUNC_CPP)

# header to avoid function callbacks using function pointers
$(KINDERIV_H_PATH): $(mod_all_cpp_files) build_always | $(MOD_TO_CPP_DIR)
	cd $(MOD_TO_CPP_DIR); \
	@PYTHON_EXECUTABLE@ $(INSTALL_SHARE_CORENRN_DIR)/kinderiv.py;

# symlink to cpp files provided by coreneuron
$(MOD_TO_CPP_DIR)/%.cpp: $(INSTALL_SHARE_MOD2C_DIR)/%.cpp | $(MOD_TO_CPP_DIR)
	ln -s $< $@

$(DIMPLIC_CPP): $(DERIVIMPLICIT_CPP_FILE) | $(MOD_TO_CPP_DIR)
	ln -s $(DERIVIMPLICIT_CPP_FILE) $(DIMPLIC_CPP)

# create directories needed
$(MOD_TO_CPP_DIR):
	mkdir -p $(MOD_TO_CPP_DIR)

$(MOD_OBJS_DIR):
	mkdir -p $(MOD_OBJS_DIR)

.PHONY: build_always

$(VERBOSE).SILENT: